#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

using namespace std;

// Абстрактний базовий клас для зберігання та обробки послідовності цифр.
class CDataChain {
public:
    CDataChain() {}
    virtual ~CDataChain() {}

    // Віртуальний метод для генерації послідовності цифр, який повинен бути реалізований у нащадках.
    virtual void Generate(int nDepth, int nMaxLength = 0) = 0;

    // Метод для отримання довжини поточної послідовності.
    size_t GetLength() const {
        return m_sChain.length();
    }
    
    // Метод для пошуку підстрічки у поточній послідовності, починаючи з позиції nPos.
    int Find(const char* sSubStr, int nPos = 0) const {
        string str(sSubStr);
        size_t pos = m_sChain.find(str, nPos);
        
        return pos == string::npos ? -1 : static_cast<int>(pos);
    }
    
    // Метод для отримання підстрічки з послідовності, починаючи з позиції nPos.
    string GetSubStr(int nPos, int nLength = -1) const {
        if (nLength == -1 || nPos + nLength > GetLength()) {
            return m_sChain.substr(nPos);
        }
        return m_sChain.substr(nPos, nLength);
    }
    
    // Метод для отримання всієї поточної послідовності цифр.
    const char* GetFullString() const {
        return m_sChain.c_str();
    }

    // Метод для безпечного встановлення нової послідовності цифр.
    void SetChain(const string& newChain) {
        m_sChain = newChain;
    }

protected:
    // Зберігання згенерованої послідовності у форматі рядка.
    string m_sChain;
};

// Клас-нащадок, який реалізує методи генерації та обробки послідовності цифр.
class CDataSimple : public CDataChain {
public:
    CDataSimple() {}
    virtual ~CDataSimple() {}

    // Реалізація методу генерації послідовності через конкатенацію натуральних чисел.
    void Generate(int nDepth, int nMaxLength = 0) override {
        ostringstream ss;
        for (int i = 0; i <= nDepth; ++i) {
            ss << i; // Додаємо число до стрічки.
            // Переривання циклу, якщо досягнуто максимальної довжини.
            if (nMaxLength > 0 && ss.str().length() >= static_cast<size_t>(nMaxLength)) {
                break; 
            }
        }
        // Встановлюємо згенеровану послідовність з урахуванням максимальної довжини.
        m_sChain = ss.str().substr(0, nMaxLength);
    }
};

// Клас для роботи з об'єктом CDataChain та збереження/відновлення стану.
class CWorkspace {
public:
    // Конструктор приймає посилання на об'єкт CDataChain.
    CWorkspace(CDataChain& data) : m_refChain(data) {}

    // Ініціалізує послідовність цифр використовуючи об'єкт CDataChain.
    void Init(int nDepth, int nLength) {
        m_refChain.Generate(nDepth, nLength);
    }

    // Повертає стрічку із згенерованою послідовністю цифр.
    const char* GetChainString() const {
        return m_refChain.GetFullString();
    }

    // Зберігає стан Workspace у файл.
    bool Save(const string& sFilepath) {
        ofstream file(sFilepath);
        if (file.is_open()) {
            file << GetChainString();
            file.close();
            return true;
        }
        return false;
    }

    // Відновлює стан Workspace із файлу.
    bool Load(const string& sFilepath) {
        ifstream file(sFilepath);
        if (file.is_open()) {
            string line;
            getline(file, line);
            m_refChain.SetChain(line); // Відновлюємо послідовність через новий метод.
            file.close();
            return true;
        }
        return false;
    }

private:
    // Посилання на контейнер із послідовністю цифр.
    CDataChain& m_refChain;
};

int main() {
    CDataSimple data;
    CWorkspace ws(data);

    ws.Init(15, 20);

    cout << "Chain: " << ws.GetChainString() << endl;

    string filepath = "workspace.txt";
    if (ws.Save(filepath)) {
        cout << "Workspace saved to file." << endl;
    } else {
        cout << "Failed to save workspace." << endl;
    }

    CDataSimple newData;
    CWorkspace newWs(newData);
    if (newWs.Load(filepath)) {
        cout << "Workspace loaded from file." << endl;
        cout << "Loaded chain: " << newWs.GetChainString() << endl;
    } else {
        cout << "Failed to load workspace." << endl;
    }

    return 0;
}
