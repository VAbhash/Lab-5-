#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <fstream>

using namespace std;

// Клас для зберігання та генерації послідовності цифр
class CDataChain {
public:
    CDataChain() {}
    virtual ~CDataChain() {}

    // Генерація послідовності цифр
    virtual void Generate(int nDepth, int nMaxLength = 0) = 0;

    // Отримання довжини послідовності
    size_t GetLength() const { return m_sChain.length(); }

    // Пошук підстрічки в послідовності
    int Find(const char* sSubStr, int nPos = 0) const {
        string str(sSubStr);
        size_t pos = m_sChain.find(str, nPos);
        return pos == string::npos ? -1 : static_cast<int>(pos);
    }

    // Отримання підстрічки за певними параметрами
    string GetSubStr(int nPos, int nLength = -1) const {
        if (nLength == -1 || nPos + nLength > GetLength()) {
            return m_sChain.substr(nPos);
        }
        return m_sChain.substr(nPos, nLength);
    }

    // Отримання повної послідовності як C-style рядок
    const char* GetFullString() const { return m_sChain.c_str(); }

    // Встановлення нової послідовності
    void SetChain(const string& newChain) { m_sChain = newChain; }

protected:
    string m_sChain;
};

// Наслідуваний клас для простої генерації послідовності
class CDataSimple : public CDataChain {
public:
    CDataSimple() {}
    virtual ~CDataSimple() {}

    // Генерація простої послідовності цифр
    void Generate(int nDepth, int nMaxLength = 0) override {
        ostringstream ss;
        for (int i = 0; i <= nDepth; ++i) {
            ss << i;
            if (nMaxLength > 0 && ss.str().length() >= static_cast<size_t>(nMaxLength)) {
                break;
            }
        }
        m_sChain = ss.str().substr(0, nMaxLength);
    }
};

// Клас CWorkspace для роботи з даними
class CWorkspace {
public:
    CWorkspace(CDataChain& data) : m_data(data) {}

    // Генерація нової послідовності через об'єкт CDataChain
    void Generate(int nDepth, int nMaxLength) { m_data.Generate(nDepth, nMaxLength); }

    // Отримання повної послідовності як C-style рядок
    const char* GetChainString() const { return m_data.GetFullString(); }

    // Встановлення нової послідовності через об'єкт CDataChain
    void SetChain(const string& newChain) { m_data.SetChain(newChain); }

    // Пошук підстрічки в послідовності через об'єкт CDataChain
    int FindSubstring(const char* sSubStr, int nPos = 0) const { return m_data.Find(sSubStr, nPos); }

private:
    CDataChain& m_data;
};

// Тип функції команди
typedef void (*ptDlgCommandFunc)(CWorkspace& ws);

// Клас для зв'язування команд з функціями
class CDlgCommand {
public:
    CDlgCommand(const char* sName, ptDlgCommandFunc pFunc = NULL) : m_sName(sName), m_pFunc(pFunc) {}

    // Отримання назви команди
    const char* GetName() const { return m_sName.c_str(); }

    // Виконання команди через функцію, яку вона представляє
    void Run(CWorkspace& ws) const {
        if (m_pFunc) (*m_pFunc)(ws);
        else cout << "No function associated with this command." << endl;
    }

private:
    string m_sName;
    ptDlgCommandFunc m_pFunc;
};

// Клас для управління діалогом
class CDialogManager {
public:
    CDialogManager(CWorkspace& ws) : m_refWorkspace(ws) {
        m_aCommands.push_back(new CDlgCommand("Quit"));
    }

    // Звільнення ресурсів при завершенні роботи
    ~CDialogManager() {
        for (CDlgCommand* command : m_aCommands) {
            delete command;
        }
    }

    // Реєстрація нової команди
    void RegisterCommand(const char* sName, ptDlgCommandFunc pFunc) {
        m_aCommands.push_back(new CDlgCommand(sName, pFunc));
    }

    // Запуск діалогового інтерфейсу
    void Run() {
        int nCommand = -1;
        while (nCommand != 0) {
            cout << endl;
            for (size_t i = 0; i < m_aCommands.size(); i++) {
                cout << i << ". " << m_aCommands[i]->GetName() << endl;
            }
            cout << "Enter command: ";
            cin >> nCommand;
            if (nCommand > 0 && nCommand < (int)m_aCommands.size()) {
                m_aCommands[nCommand]->Run(m_refWorkspace);
            }
        }
    }

private:
    vector<CDlgCommand*> m_aCommands;
    CWorkspace& m_refWorkspace;
};

// Функції для команд користувача

// Ініціалізація послідовності через об'єкт CDataChain
void Init(CWorkspace& ws) {
    int depth, maxLength;
    cout << "Enter depth for sequence generation: ";
    cin >> depth;
    cout << "Enter maximum length for the sequence: ";
    cin >> maxLength;
    ws.Generate(depth, maxLength);
    cout << "Sequence initialized." << endl;
}

// Виведення повної послідовності на екран через об'єкт CDataChain
void ShowFullSequence(CWorkspace& ws) {
    cout << "Current sequence: " << ws.GetChainString() << endl;
}

// Збереження послідовності у файл через об'єкт CDataChain
void Save(CWorkspace& ws) {
    string filepath;
    cout << "Enter filename to save the sequence: ";
    cin >> filepath;
    ofstream file(filepath);
    if (file.is_open()) {
        file << ws.GetChainString();
        file.close();
        cout << "Sequence saved to " << filepath << endl;
    } else {
        cout << "Error: Could not open file " << filepath << endl;
    }
}

// Завантаження послідовності з файлу через об'єкт CDataChain
void Load(CWorkspace& ws) {
    string filepath;
    cout << "Enter filename to load the sequence from: ";
    cin >> filepath;
    ifstream file(filepath);
    if (file.is_open()) {
        string line;
        getline(file, line);
        ws.SetChain(line);
        cout << "Sequence loaded from " << filepath << endl;
    } else {
        cout << "Error: Could not open file " << filepath << endl;
    }
}

// Пошук підстрічки в послідовності через об'єкт CDataChain
void FindSubstring(CWorkspace& ws) {
    string substring;
    cout << "Enter substring to find: ";
    cin >> substring;
    int position = ws.FindSubstring(substring.c_str());
    if (position != -1) {
        cout << "Substring found at position: " << position << endl;
    } else {
        cout << "Substring not found in the sequence." << endl;
    }
}


int main() {
    
    CDataSimple data;
    CWorkspace ws(data);
    CDialogManager mgr(ws);

    // Реєстрація команд для діалогового інтерфейсу
    mgr.RegisterCommand("Init sequence", Init);
    mgr.RegisterCommand("Show sequence", ShowFullSequence);
    mgr.RegisterCommand("Save", Save);
    mgr.RegisterCommand("Load", Load);
    mgr.RegisterCommand("Find substring", FindSubstring);  

    
    mgr.Run();

    return 0;
}
