#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <fstream>
#include <cstdlib>

using namespace std;

class CDataChain;
// Клас представляє ланку даних у послідовності
class CLink {
public:
    CLink(CDataChain& refChain);
    virtual ~CLink();

    bool Attach(const char* sSubStr);
    virtual void Output(ostream& os);
    virtual bool Save(ostream& so);
    virtual bool Load(istream& is);

protected:
    CDataChain& m_refChain; // Посилання на об'єкт CDataChain для роботи з даними.
    int m_nPos;             // Позиція ланки в послідовності.
    int m_nSize;            // Розмір ланки (кількість символів).
};

// Клас для представлення послідовностей даних
class CWorkspace;

typedef vector<CLink*> LinksArray;
// Клас для представлення послідовностей даних
class CDataChain {
public:
    CDataChain() {}
    virtual ~CDataChain() {}

    virtual void Generate(int nDepth, int nMaxLength = 0) = 0;
    size_t GetLength() const { return m_sChain.length(); }
    int Find(const char* sSubStr, int nPos = 0) const {
        string str(sSubStr);
        size_t pos = m_sChain.find(str, nPos);
        return pos == string::npos ? -1 : static_cast<int>(pos);
    }
    string GetSubStr(int nPos, int nLength = -1) const {
        if (nLength == -1 || nPos + nLength > GetLength()) {
            return m_sChain.substr(nPos);
        }
        return m_sChain.substr(nPos, nLength);
    }
    const char* GetFullString() const { return m_sChain.c_str(); }
    void SetChain(const string& newChain) { m_sChain = newChain; }

protected:
    string m_sChain; // Зберігання послідовності у форматі рядка.
};
// Клас для генерації простих послідовностей даних
class CDataSimple : public CDataChain {
public:
    CDataSimple() {}
    virtual ~CDataSimple() {}

    void Generate(int nDepth, int nMaxLength = 0) override {
        ostringstream ss;
        for (int i = 0; i <= nDepth; ++i) {
            ss << i;
            if (nMaxLength > 0 && ss.str().length() >= static_cast<size_t>(nMaxLength)) {
                break;
            }
        }
        m_sChain = ss.str().substr(0, nMaxLength);
    }
};
// Клас для роботи з послідовністю даних та ланками
class CWorkspace {
public:
    CWorkspace(CDataChain& data) : m_data(data) {}

    void Generate(int nDepth, int nMaxLength) { m_data.Generate(nDepth, nMaxLength); }
    const char* GetChainString() const { return m_data.GetFullString(); }
    void SetChain(const string& newChain) { m_data.SetChain(newChain); }
    int FindSubstring(const char* sSubStr, int nPos = 0) const { return m_data.Find(sSubStr, nPos); }

    bool AddLink(int nStartPos, int nLength);
    bool RemoveLink(int nPosInList);
    bool ShowAllLinks();

private:
    CDataChain& m_data;  // Посилання на об'єкт CDataChain для роботи з даними.
    LinksArray m_aLinks;  // Вектор для зберігання об'єктів CLink.
};

// Тип для зберігання команд
typedef void (*ptDlgCommandFunc)(CWorkspace& ws);

// Клас, який представляє команду для взаємодії з користувачем
class CDlgCommand {
public:
    CDlgCommand(const char* sName, ptDlgCommandFunc pFunc = NULL) : m_sName(sName), m_pFunc(pFunc) {}

    const char* GetName() const { return m_sName.c_str(); }

    void Run(CWorkspace& ws) const {
        if (m_pFunc) (*m_pFunc)(ws);
        else cout << "No function associated with this command." << endl;
    }

private:
    string m_sName;          // Назва команди.
    ptDlgCommandFunc m_pFunc; // Вказівник на функцію, яку викликає команда.
};

// Клас для управління командами та взаємодією з користувачем
class CDialogManager {
public:
    CDialogManager(CWorkspace& ws) : m_refWorkspace(ws) {
        RegisterCommand("0. Quit", Quit);
        RegisterCommand("1. Show All Links", ShowAllLinks);
    }

    ~CDialogManager() {
        for (CDlgCommand* command : m_aCommands) {
            delete command;
        }
    }

    void RegisterCommand(const char* sName, ptDlgCommandFunc pFunc = NULL) {
        m_aCommands.push_back(new CDlgCommand(sName, pFunc));
    }

    void Run() {
        int nCommand = -1;
        while (nCommand != 0) {
            cout << endl;
            for (size_t i = 0; i < m_aCommands.size(); i++) {
                cout << m_aCommands[i]->GetName() << endl;
            }
            cout << "Enter command: ";
            cin >> nCommand;
            if (nCommand >= 0 && nCommand < static_cast<int>(m_aCommands.size())) {
                m_aCommands[static_cast<size_t>(nCommand)]->Run(m_refWorkspace);
            }
        }
    }

    static void ShowAllLinks(CWorkspace& ws) {
        ws.ShowAllLinks();
    }

    static void Quit(CWorkspace& ws) {
        cout << "Quitting the program." << endl;
        exit(0);
    }

private:
    vector<CDlgCommand*> m_aCommands; // Вектор для зберігання об'єктів CDlgCommand.
    CWorkspace& m_refWorkspace;       // Посилання на об'єкт CWorkspace для роботи з даними.
};

// Ініціалізація послідовності
void Init(CWorkspace& ws) {
    int depth, maxLength;
    cout << "Enter depth for sequence generation: ";
    cin >> depth;
    cout << "Enter maximum length for the sequence: ";
    cin >> maxLength;
    ws.Generate(depth, maxLength);
    cout << "Sequence initialized." << endl;
}

// Виведення повної послідовності
void ShowFullSequence(CWorkspace& ws) {
    cout << "Current sequence: " << ws.GetChainString() << endl;
}

// Збереження послідовності в файл
void Save(CWorkspace& ws) {
    string filepath;
    cout << "Enter filename to save the sequence: ";
    cin >> filepath;
    ofstream file(filepath);
    if (file.is_open()) {
        file << ws.GetChainString();
        file.close();
        cout << "Sequence saved to " << filepath << endl;
    } else {
        cout << "Error: Could not open file " << filepath << endl;
    }
}

// Завантаження послідовності з файлу
void Load(CWorkspace& ws) {
    string filepath;
    cout << "Enter filename to load the sequence from: ";
    cin >> filepath;
    ifstream file(filepath);
    if (file.is_open()) {
        string line;
        getline(file, line);
        ws.SetChain(line);
        cout << "Sequence loaded from " << filepath << endl;
    } else {
        cout << "Error: Could not open file " << filepath << endl;
    }
}

// Пошук підстрічки у послідовності
void FindSubstring(CWorkspace& ws) {
    string substring;
    cout << "Enter substring to find: ";
    cin >> substring;
    int position = ws.FindSubstring(substring.c_str());
    if (position != -1) {
        cout << "Substring found at position: " << position << endl;
    } else {
        cout << "Substring not found in the sequence." << endl;
    }
}

// Додавання ланки до послідовності
bool CWorkspace::AddLink(int nStartPos, int nLength) {
    if (nStartPos < 0 || nLength <= 0) {
        cout << "Error: Invalid parameters for AddLink." << endl;
        return false;
    }

    if (nStartPos + nLength > static_cast<int>(m_data.GetLength())) {
        cout << "Error: Link position and length exceed the sequence boundaries." << endl;
        return false;
    }

    CLink* newLink = new CLink(m_data);
    if (!newLink->Attach(m_data.GetSubStr(nStartPos, nLength).c_str())) {
        cout << "Error: Failed to attach link to the specified substring." << endl;
        delete newLink;
        return false;
    }

    m_aLinks.push_back(newLink);

    return true;
}

// Видалення ланки з послідовності
bool CWorkspace::RemoveLink(int nPosInList) {
    if (nPosInList < 0 || nPosInList >= static_cast<int>(m_aLinks.size())) {
        cout << "Error: Invalid position for RemoveLink." << endl;
        return false;
    }

    delete m_aLinks[static_cast<size_t>(nPosInList)];
    m_aLinks.erase(m_aLinks.begin() + nPosInList);

    return true;
}

// Виведення всіх ланок в послідовності
bool CWorkspace::ShowAllLinks() {
    if (m_aLinks.empty()) {
        cout << "No links in the list." << endl;
        return false;
    }

    cout << "All Links:" << endl;
    for (size_t i = 0; i < m_aLinks.size(); ++i) {
        cout << i << ". ";
        m_aLinks[i]->Output(cout);
        cout << endl;
    }

    return true;
}

// Точка входу у програму
int main() {
    CDataSimple data;
    CWorkspace ws(data);
    CDialogManager mgr(ws);

    // Реєстрація команд для взаємодії з користувачем
    mgr.RegisterCommand("2. Init sequence", Init);
    mgr.RegisterCommand("3. Show sequence", ShowFullSequence);
    mgr.RegisterCommand("4. Save", Save);
    mgr.RegisterCommand("5. Load", Load);
    mgr.RegisterCommand("6. Find substring", FindSubstring);

    
    mgr.Run();

    return 0;
}
