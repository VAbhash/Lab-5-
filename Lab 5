#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <fstream>
#include <cstdlib>

using namespace std;

class CDataChain;
// Клас, який представляє ланку даних у послідовності
class CLink {
public:
    CLink(CDataChain& refChain);
    virtual ~CLink();

    bool Attach(const char* sSubStr);
    virtual void Output(ostream& os);
    virtual bool Save(ostream& so);
    virtual bool Load(istream& is);

protected:
    CDataChain& m_refChain;
    int m_nPos;
    int m_nSize;
};

class CDataChain {
public:
    CDataChain() {}
    virtual ~CDataChain() {}

    virtual void Generate(int nDepth, int nMaxLength = 0) = 0;
    size_t GetLength() const { return m_sChain.length(); }
    int Find(const char* sSubStr, int nPos = 0) const {
        string str(sSubStr);
        size_t pos = m_sChain.find(str, nPos);
        return pos == string::npos ? -1 : static_cast<int>(pos);
    }
    string GetSubStr(int nPos, int nLength = -1) const {
        if (nLength == -1 || nPos + nLength > GetLength()) {
            return m_sChain.substr(nPos);
        }
        return m_sChain.substr(nPos, nLength);
    }
    const char* GetFullString() const { return m_sChain.c_str(); }
    void SetChain(const string& newChain) { m_sChain = newChain; }

protected:
    string m_sChain;  // Зберігання послідовності у форматі рядка
};
// Клас для генерації простих послідовностей даних
class CDataSimple : public CDataChain {
public:
    CDataSimple() {}
    virtual ~CDataSimple() {}

    void Generate(int nDepth, int nMaxLength = 0) override {  // Метод для генерації простої послідовності
        ostringstream ss;
        for (int i = 0; i <= nDepth; ++i) {
            ss << i;
            if (nMaxLength > 0 && ss.str().length() >= static_cast<size_t>(nMaxLength)) {
                break;
            }
        }
        m_sChain = ss.str().substr(0, nMaxLength);
    }
};
// Клас для роботи з послідовністю даних та ланками
class CWorkspace {
public:
    CWorkspace(CDataChain& data) : m_data(data) {}

    void Generate(int nDepth, int nMaxLength) { m_data.Generate(nDepth, nMaxLength); } // Метод для генерації послідовності в робочому просторі
    const char* GetChainString() const { return m_data.GetFullString(); } // Метод для отримання рядка послідовності
    void SetChain(const string& newChain) { m_data.SetChain(newChain); }   // Метод для встановлення нової послідовності
    int FindSubstring(const char* sSubStr, int nPos = 0) const { return m_data.Find(sSubStr, nPos); } // Метод для пошуку підстрічки в послідовності

    bool AddLink(int nStartPos, int nLength); // Метод для додавання лінка до послідовності
    bool RemoveLink(int nPosInList);   // Метод для видалення лінка з послідовності
    bool ShowAllLinks();  // Метод для виведення усіх лінків в послідовності

private:
    CDataChain& m_data; // Посилання на об'єкт CDataChain для роботи з даними
    vector<CLink*> m_aLinks; // Вектор для зберігання об'єктів CLink

};

typedef void (*ptDlgCommandFunc)(CWorkspace& ws); // Тип для зберігання команд

// Клас, який представляє команду для взаємодії з користувачем
class CDlgCommand {
public:
    CDlgCommand(const char* sName, ptDlgCommandFunc pFunc = NULL) : m_sName(sName), m_pFunc(pFunc) {}

    const char* GetName() const { return m_sName.c_str(); }

    void Run(CWorkspace& ws) const {
        if (m_pFunc) (*m_pFunc)(ws);
        else cout << "No function associated with this command." << endl;
    }

private:
    string m_sName;
    ptDlgCommandFunc m_pFunc;
};
// Клас для управління командами та взаємодією з користувачем
class CDialogManager {
public:
    CDialogManager() {}

    ~CDialogManager() {
        for (CDlgCommand* command : m_aCommands) {
            delete command;
        }
    }

    void RegisterCommand(const char* sName, ptDlgCommandFunc pFunc = NULL) { // Метод для реєстрації команди
        m_aCommands.push_back(new CDlgCommand(sName, pFunc));
    }

    void Run(CWorkspace& ws) {
        int nCommand = -1;
        while (nCommand != 0) {
            cout << endl;
            for (size_t i = 0; i < m_aCommands.size(); i++) {
                cout << m_aCommands[i]->GetName() << endl;
            }
            cout << "Enter command: ";
            cin >> nCommand;
            if (nCommand >= 0 && nCommand < static_cast<int>(m_aCommands.size())) {
                m_aCommands[static_cast<size_t>(nCommand)]->Run(ws);
            }
        }
    }

    static void ShowAllLinks(CWorkspace& ws) {
        ws.ShowAllLinks();
    }

    static void Quit(CWorkspace& ws) {
        cout << "Quitting the program." << endl;
        exit(0);
    }

    static void AddLink(CWorkspace& ws) {
        int startPos, length;
        cout << "Enter start position for the link: ";
        cin >> startPos;
        cout << "Enter length for the link: ";
        cin >> length;
        ws.AddLink(startPos, length);
    }

    static void RemoveLink(CWorkspace& ws) {
        int pos;
        cout << "Enter position of the link to remove: ";
        cin >> pos;
        ws.RemoveLink(pos);
    }

private:
    vector<CDlgCommand*> m_aCommands;
};

// Ініціалізація послідовності
void Init(CWorkspace& ws) {
    int depth, maxLength;
    cout << "Enter depth for sequence generation: ";
    cin >> depth;
    cout << "Enter maximum length for the sequence: ";
    cin >> maxLength;
    ws.Generate(depth, maxLength);
    cout << "Sequence initialized." << endl;
}

// Виведення повної послідовності
void ShowFullSequence(CWorkspace& ws) {
    cout << "Current sequence: " << ws.GetChainString() << endl;
}

// Збереження послідовності в файл
void Save(CWorkspace& ws) {
    string filepath;
    cout << "Enter filename to save the sequence: ";
    cin >> filepath;
    ofstream file(filepath);
    if (file.is_open()) {
        file << ws.GetChainString();
        file.close();
        cout << "Sequence saved to " << filepath << endl;
    } else {
        cout << "Error: Could not open file " << filepath << endl;
    }
}

// Завантаження послідовності з файлу
void Load(CWorkspace& ws) {
    string filepath;
    cout << "Enter filename to load the sequence from: ";
    cin >> filepath;
    ifstream file(filepath);
    if (file.is_open()) {
        string line;
        getline(file, line);
        ws.SetChain(line);
        cout << "Sequence loaded from " << filepath << endl;
    } else {
        cout << "Error: Could not open file " << filepath << endl;
    }
}

// Пошук підстрічки у послідовності
void FindSubstring(CWorkspace& ws) {
    string substring;
    cout << "Enter substring to find: ";
    cin >> substring;
    int position = ws.FindSubstring(substring.c_str());
    if (position != -1) {
        cout << "Substring found at position: " << position << endl;
    } else {
        cout << "Substring not found in the sequence." << endl;
    }
}

CLink::CLink(CDataChain& refChain) : m_refChain(refChain), m_nPos(0), m_nSize(0) {
    
}

CLink::~CLink() {
    
}

bool CLink::Attach(const char* sSubStr) {
    if (sSubStr == nullptr) {
        cerr << "Error: Invalid substring." << endl;
        return false;
    }

    m_nSize = static_cast<int>(strlen(sSubStr));

    

    return true;
}

void CLink::Output(ostream& os) {
    os << "Link at position " << m_nPos << " with size " << m_nSize;
}

bool CLink::Save(ostream& so) {
    so << m_nPos << ' ' << m_nSize << '\n';

    

    return true;
}

bool CLink::Load(istream& is) {
    is >> m_nPos >> m_nSize;

    

    return true;
}

// Додавання лінка до послідовності
bool CWorkspace::AddLink(int nStartPos, int nLength) {
    if (nStartPos < 0 || nLength <= 0) {
        cout << "Error: Invalid parameters for AddLink." << endl;
        return false;
    }

    if (nStartPos + nLength > static_cast<int>(m_data.GetLength())) {
        cout << "Error: Link position and length exceed the sequence boundaries." << endl;
        return false;
    }

    CLink* newLink = new CLink(m_data);
    if (!newLink->Attach(m_data.GetSubStr(nStartPos, nLength).c_str())) {
        cout << "Error: Failed to attach link to the specified substring." << endl;
        delete newLink;
        return false;
    }

    m_aLinks.push_back(newLink);

    return true;
}
// Видалення ланки з послідовності
bool CWorkspace::RemoveLink(int nPosInList) {
    if (nPosInList < 0 || nPosInList >= static_cast<int>(m_aLinks.size())) {
        cout << "Error: Invalid position for RemoveLink." << endl;
        return false;
    }

    delete m_aLinks[static_cast<size_t>(nPosInList)];
    m_aLinks.erase(m_aLinks.begin() + nPosInList);

    return true;
}
// Виведення всіх лінків в послідовності
bool CWorkspace::ShowAllLinks() {
    if (m_aLinks.empty()) {
        cout << "No links in the list." << endl;
        return false;
    }

    cout << "All Links:" << endl;
    for (size_t i = 0; i < m_aLinks.size(); ++i) {
        cout << i << ". ";
        m_aLinks[i]->Output(cout);
        cout << endl;
    }

    return true;
}

int main() {
    CDataSimple data;
    CWorkspace ws(data);
    CDialogManager mgr;

    mgr.RegisterCommand("0. Quit", CDialogManager::Quit);
    mgr.RegisterCommand("1. Show All Links", CDialogManager::ShowAllLinks);
    mgr.RegisterCommand("2. Init sequence", Init);
    mgr.RegisterCommand("3. Show sequence", ShowFullSequence);
    mgr.RegisterCommand("4. Save", Save);
    mgr.RegisterCommand("5. Load", Load);
    mgr.RegisterCommand("6. Find substring", FindSubstring);
    mgr.RegisterCommand("7. Add link", CDialogManager::AddLink);
    mgr.RegisterCommand("8. Remove link", CDialogManager::RemoveLink);

    mgr.Run(ws);

    return 0;
}
