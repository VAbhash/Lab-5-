#include <iostream>
#include <fstream>
#include <string>
#include <sstream>


class CDataChain {
public:
    CDataChain() {}
    virtual ~CDataChain() {}

    // Віртуальний метод для генерації послідовності цифр.
    virtual void Generate(int nDepth, int nMaxLength = 0) = 0;

    // Отримання довжини згенерованої послідовності.
    size_t GetLength() const {
        return m_sChain.length();
    }

    // Пошук підстрічки у згенерованій послідовності, починаючи з позиції nPos.
    int Find(const char* sSubStr, int nPos = 0) const {
        std::string str(sSubStr);
        size_t pos = m_sChain.find(str, nPos);
        return pos == std::string::npos ? -1 : static_cast<int>(pos);
    }

    // Отримання підстрічки із згенерованої послідовності, починаючи з nPos.
    std::string GetSubStr(int nPos, int nLength = -1) const {
        if (nLength == -1 || nPos + nLength > GetLength()) {
            return m_sChain.substr(nPos);
        }
        return m_sChain.substr(nPos, nLength);
    }

    // Повернення всієї згенерованої послідовності цифр.
    const char* GetFullString() const {
        return m_sChain.c_str();
    }

    // Метод для безпечного встановлення нової послідовності цифр.
    void SetChain(const std::string& newChain) {
        m_sChain = newChain;
    }

protected:
    // Зберігання згенерованої послідовності у форматі рядка.
    std::string m_sChain;
};

// Клас-нащадок, який реалізує методи генерації та обробки послідовності цифр.
class CDataSimple : public CDataChain {
public:
    CDataSimple() {}
    virtual ~CDataSimple() {}

    // Реалізація методу генерації послідовності через конкатенацію натуральних чисел.
    void Generate(int nDepth, int nMaxLength = 0) override {
        std::ostringstream ss;
        for (int i = 0; i <= nDepth; ++i) {
            ss << i;
            // Переривання циклу, якщо досягнуто максимальної довжини.
            if (nMaxLength > 0 && ss.str().length() >= static_cast<size_t>(nMaxLength)) {
                break;
            }
        }
        // Обмеження згенерованої послідовності до максимальної довжини, якщо вказано.
        m_sChain = ss.str().substr(0, nMaxLength);
    }
};

// Клас для роботи з об'єктом CDataChain та збереження/відновлення стану.
class CWorkspace {
public:
    // Конструктор приймає посилання на об'єкт CDataChain.
    CWorkspace(CDataChain& data) : m_refChain(data) {}

    ~CWorkspace() {}

    // Ініціалізує послідовність цифр використовуючи об'єкт CDataChain.
    void Init(int nDepth, int nLength) {
        m_refChain.Generate(nDepth, nLength);
    }

    // Повертає стрічку із згенерованою послідовністю цифр.
    const char* GetChainString() const {
        return m_refChain.GetFullString();
    }

    // Зберігає стан Workspace у файл.
    bool Save(const std::string& sFilepath) {
        std::ofstream file(sFilepath);
        if (file.is_open()) {
            file << GetChainString();
            file.close();
            return true;
        }
        return false;
    }

    // Відновлює стан Workspace із файлу.
    bool Load(const std::string& sFilepath) {
        std::ifstream file(sFilepath);
        if (file.is_open()) {
            std::string line;
            std::getline(file, line);
            m_refChain.SetChain(line); // Відновлюємо послідовність через новий метод.
            file.close();
            return true;
        }
        return false;
    }

private:
    // Посилання на контейнер із послідовністю цифр.
    CDataChain& m_refChain;
};

int main() {
    CDataSimple data;
    CWorkspace ws(data);

    // Ініціалізуємо послідовність цифр.
    ws.Init(15, 20);

    // Показуємо згенеровану послідовність.
    std::cout << "Chain: " << ws.GetChainString() << std::endl;

    // Зберігаємо стан у файл.
    std::string filepath = "workspace.txt";
    if (ws.Save(filepath)) {
        std::cout << "Workspace saved to file." << std::endl;
    } else {
        std::cout << "Failed to save workspace." << std::endl;
    }

    // Створення нового Workspace та відновлення стану із файлу.
    CDataSimple newData;
    CWorkspace newWs(newData);
    if (newWs.Load(filepath)) {
        std::cout << "Workspace loaded from file." << std::endl;
        std::cout << "Loaded chain: " << newWs.GetChainString() << std::endl;
    } else {
        std::cout << "Failed to load workspace." << std::endl;
    }

    return 0;
}
